<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>JinzhePro</title><link>https://jinzhepro.github.io</link><description>再努力一次！</description><copyright>JinzhePro</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://jinzhepro.github.io/logo.png</url><title>avatar</title><link>https://jinzhepro.github.io</link></image><lastBuildDate>Fri, 20 Dec 2024 02:38:22 +0000</lastBuildDate><managingEditor>JinzhePro</managingEditor><ttl>60</ttl><webMaster>JinzhePro</webMaster><item><title>语句的执行</title><link>https://jinzhepro.github.io/post/yu-ju-de-zhi-xing.html</link><description>## Completion Record 标准类型&#13;
&#13;
1. [[type]]：完成的类型（break、continue、return、throw、normal）&#13;
2. [[value]] ：返回值（如果没有，则为empty）&#13;
3. [[target]] ：语句的目标&#13;
&#13;
```jsx&#13;
{&#13;
  var a = 1; // normal, undefined, empty&#13;
  return 2; // return, 2, empty&#13;
  a++;&#13;
  console.log(a);&#13;
} // return, 2, empty&#13;
// 带有target的语句&#13;
outer: while (true) {&#13;
  inner: while (true) {&#13;
    break outer;&#13;
  }&#13;
}&#13;
console.log('finished');&#13;
```。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/yu-ju-de-zhi-xing.html</guid><pubDate>Fri, 20 Dec 2024 02:38:00 +0000</pubDate></item><item><title>异步编程</title><link>https://jinzhepro.github.io/post/yi-bu-bian-cheng.html</link><description>## 回调函数&#13;
&#13;
最原始的异步编程方法（回调地狱）&#13;
&#13;
## Promise&#13;
&#13;
在一定程度上解决了回调地狱的问题，但是then多了之后也不太友好。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/yi-bu-bian-cheng.html</guid><pubDate>Fri, 20 Dec 2024 02:37:25 +0000</pubDate></item><item><title>复杂度分析</title><link>https://jinzhepro.github.io/post/fu-za-du-fen-xi.html</link><description>&gt; 复杂度分析是学习数据结构与算法的前提。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/fu-za-du-fen-xi.html</guid><pubDate>Fri, 20 Dec 2024 02:31:16 +0000</pubDate></item><item><title>JavaScript手写函数</title><link>https://jinzhepro.github.io/post/JavaScript-shou-xie-han-shu.html</link><description>## 手写一个new&#13;
&#13;
```jsx&#13;
function create() {&#13;
  // 创建一个空对象&#13;
  let obj = new Object();&#13;
&#13;
  // 参数转数组&#13;
  var args = Array.prototype.slice.call(arguments);&#13;
&#13;
  // 获取构造函数&#13;
  let Con = args[0];&#13;
&#13;
  // 链接原型&#13;
  obj._proto_ = Con.prototype;&#13;
&#13;
  // binding this&#13;
  let result = Con.apply(obj, args.slice(1));&#13;
&#13;
  // return obj&#13;
  return typeof result === 'object' ? result : obj;&#13;
}&#13;
```&#13;
&#13;
## 手写一个call&#13;
&#13;
```jsx&#13;
Function.prototype.myCall = function (params) {&#13;
  // 获取对象&#13;
  let params = params || window;&#13;
&#13;
  // 将作用域添加到新函数里&#13;
  params.fn = this;&#13;
&#13;
  // 获取参数&#13;
  let args = [...arguments].slice(1);&#13;
&#13;
  // 执行新函数&#13;
  let result = parmas.fn(...args);&#13;
&#13;
  // 删除函数&#13;
  delete params.fn;&#13;
&#13;
  return result;&#13;
};&#13;
```&#13;
&#13;
## 手写一个apply&#13;
&#13;
```jsx&#13;
Function.prototype.myApply = function (params) {&#13;
  // 获取对象&#13;
  let params = params || window;&#13;
&#13;
  // 将作用域添加到新函数里&#13;
  params.fn = this;&#13;
&#13;
  let result = null;&#13;
  if (argments[1]) {&#13;
    result = parmas.fn(...arguments[1]);&#13;
  } else {&#13;
    result = parmas.fn();&#13;
  }&#13;
&#13;
  // 删除函数&#13;
  delete params.fn;&#13;
&#13;
  return result;&#13;
};&#13;
```&#13;
&#13;
## 手写一个bind&#13;
&#13;
```jsx&#13;
Function.prototype.myBind = function (context) {&#13;
  let _this = this;&#13;
  return function F() {&#13;
    if (this instanceof F) {&#13;
      return new _this(...arguments);&#13;
    }&#13;
    return _this.apply(context, [...arguments]);&#13;
  };&#13;
};&#13;
```&#13;
&#13;
## 手写一个防抖函数&#13;
&#13;
防抖函数的作用是事件调用之后隔一段时间再处理函数，如果在时间之内再次触发事件就清除原来的时间重新计时。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/JavaScript-shou-xie-han-shu.html</guid><pubDate>Fri, 20 Dec 2024 02:30:15 +0000</pubDate></item><item><title>JavaScript中的this</title><link>https://jinzhepro.github.io/post/JavaScript-zhong-de-this.html</link><description>this和切换执行上下文有关，取决于函数执行时刻，调用函数时所使用的引用。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/JavaScript-zhong-de-this.html</guid><pubDate>Fri, 20 Dec 2024 02:29:23 +0000</pubDate></item><item><title>TypeScript基础语法</title><link>https://jinzhepro.github.io/post/TypeScript-ji-chu-yu-fa.html</link><description>## 类型声明&#13;
&#13;
使用 :[type] 指定变量的类型&#13;
&#13;
```tsx&#13;
let a: number = 1 // 数字&#13;
let b: string = 'zhang' // 字符串&#13;
let c: boolean = true // 布尔&#13;
let d: object = {} // 对象&#13;
let e: array = [] // 数组&#13;
let f: null = null // Null&#13;
let g: undefined = undefined // Undefined&#13;
let h: void = function(){} // 空值&#13;
let i: any = [] // 表示任意类型，可以链式传播，不会对其进行类型检查&#13;
let j: unknown; // 表示不确定类型，只能赋值给unknown和any，会进行类型检测&#13;
let k: never; // 表示一个不可能出现的值，比如抛出错误，无限循环，并可以模拟只读属性&#13;
// 未声明类型的变量默认为any&#13;
let something === let something: any;&#13;
```&#13;
&#13;
## 类型推论&#13;
&#13;
如果没有指定类型，那么TS会按照类型推论推断出一个类型&#13;
&#13;
```tsx&#13;
let myFavoriteNumber = 'seven';&#13;
myFavoriteNumber = 7; // error&#13;
```&#13;
&#13;
## 联合类型&#13;
&#13;
表示可以取多个类型的一种&#13;
&#13;
```tsx&#13;
let myFavoriteNumber: string | number;&#13;
myFavoriteNumber = 'seven';&#13;
myFavoriteNumber = 7;&#13;
// 只能访问联合类型的共有属性（类型推断）&#13;
function getLength(something: string | number): number {&#13;
  return something.toString();&#13;
}&#13;
```&#13;
&#13;
## 对象类型（interface）&#13;
&#13;
我们使用接口（Interfaces）来定义对象的类型。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/TypeScript-ji-chu-yu-fa.html</guid><pubDate>Fri, 20 Dec 2024 02:28:13 +0000</pubDate></item><item><title>前端自动化</title><link>https://jinzhepro.github.io/post/qian-duan-zi-dong-hua.html</link><description>## 前端自动化&#13;
&#13;
前端代码的自动化构建,打包,测试,部署等一系列流程&#13;
&#13;
### CI&#13;
&#13;
持续集成：不断开发新的功能,并通过测试快速发现新功能是否可与旧版本集成.&#13;
&#13;
### CD&#13;
&#13;
持续部署：不断的经过测试用例的校验,并将代码发布到测试或生产环境&#13;
&#13;
### 意义&#13;
&#13;
- 相比人工稳定,提升软件质量&#13;
- 效率迭代,便捷部署&#13;
- 快速交付,便于管理。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/qian-duan-zi-dong-hua.html</guid><pubDate>Fri, 20 Dec 2024 02:27:15 +0000</pubDate></item><item><title>封装axios请求</title><link>https://jinzhepro.github.io/post/feng-zhuang-axios-qing-qiu.html</link><description>封装axios的好处：兼容多种请求方法，不需要关心是怎么调用的，只需要传入相关参数即可使用&#13;
&#13;
我是在webpack项目里，用的到了ES6模块化进行封装&#13;
&#13;
话不多说，上代码：&#13;
&#13;
```jsx&#13;
// 引入axios&#13;
import axios from 'axios';&#13;
&#13;
// axios.create方法会创建一个axios实例，可传入一些默认配置&#13;
const httpServer = axios.create();&#13;
&#13;
// 请求拦截，请求发送之前会触发此方法&#13;
httpServer.interceptors.request.use(&#13;
  (config) =&gt; {&#13;
    // 这里可以做一些操作&#13;
    config.method = config.method || 'get'; // 区分请求方式&#13;
    return config;&#13;
  },&#13;
  (error) =&gt; {&#13;
    return Promise.reject(error); // 捕获错误&#13;
  }&#13;
);&#13;
&#13;
// 返回拦截，返回之前会触发此方法&#13;
httpServer.interceptors.response.use(&#13;
  (response) =&gt; {&#13;
    // 这里可以做一些操作&#13;
    return response;&#13;
  },&#13;
  (error) =&gt; {&#13;
    return Promise.reject(error);&#13;
  }&#13;
);&#13;
&#13;
// 定义请求方法&#13;
const fetchApi = (params) =&gt; {&#13;
  // 返回一个Promise&#13;
  return new Promise((resolve, reject) =&gt; {&#13;
    httpServer(params)&#13;
      .then((response) =&gt; {&#13;
        resolve(response);&#13;
      })&#13;
      .catch((error) =&gt; {&#13;
        // 这里可以加一些UI提示&#13;
        reject(error);&#13;
      });&#13;
  });&#13;
};&#13;
&#13;
export default fetchApi;&#13;
```&#13;
&#13;
如何使用？&#13;
&#13;
```jsx&#13;
// 引入封装好的方法&#13;
import fetchApi from './fetchApi.js';&#13;
&#13;
// 传参&#13;
fetchApi({&#13;
  methods: 'get',&#13;
  data: {&#13;
    id: 1,&#13;
    name: 2,&#13;
  },&#13;
  isLogin: true, //甚至可以有一些自定义的参数，在interceptors.request里通过config.XXX取到&#13;
}).then((res) =&gt; {&#13;
  // 取到返回值&#13;
});&#13;
```。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/feng-zhuang-axios-qing-qiu.html</guid><pubDate>Fri, 20 Dec 2024 02:26:08 +0000</pubDate></item><item><title>编写高质量JavaScript代码</title><link>https://jinzhepro.github.io/post/bian-xie-gao-zhi-liang-JavaScript-dai-ma.html</link><description>本文知识点是摘自于[[汤姆大叔博客](http://www.cnblogs.com/TomXu/)](http://www.cnblogs.com/TomXu/)，自己记录理解并学习&#13;
&#13;
## 书写可维护的代码&#13;
&#13;
软件开发是一个熵增的过程，随着软件结构越来越复杂，代码维护就变得举步维艰，当你发现bug并理解修复他是最好的。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/bian-xie-gao-zhi-liang-JavaScript-dai-ma.html</guid><pubDate>Fri, 20 Dec 2024 02:25:33 +0000</pubDate></item><item><title>V8的垃圾回收器</title><link>https://jinzhepro.github.io/post/V8-de-la-ji-hui-shou-qi.html</link><description>## 垃圾回收算法&#13;
&#13;
1. 遍历GC Root(window，DOM，栈等)标记活动对象和非活动对象&#13;
2. 回收非活动对象所占据的内存&#13;
3. 内存整理&#13;
&#13;
## 新生代和老生代&#13;
&#13;
在V8中，会把堆分成新生代和老生代两个区域&#13;
&#13;
- 新生代通常只支持1~8M的容量，存放生存时间短的对象，由**副垃圾回收器**负责。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/V8-de-la-ji-hui-shou-qi.html</guid><pubDate>Fri, 20 Dec 2024 02:20:22 +0000</pubDate></item><item><title>111</title><link>https://jinzhepro.github.io/post/111.html</link><description># 实体层&#13;
&#13;
使用物理手段链接电脑，如光缆，wifi。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/111.html</guid><pubDate>Thu, 19 Dec 2024 08:42:43 +0000</pubDate></item><item><title>关于我</title><link>https://jinzhepro.github.io/about.html</link><description>## 你好&#13;
### 1213。</description><guid isPermaLink="true">https://jinzhepro.github.io/about.html</guid><pubDate>Thu, 19 Dec 2024 09:40:40 +0000</pubDate></item></channel></rss>