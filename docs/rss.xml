<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>JinzhePro</title><link>https://jinzhepro.github.io</link><description>再努力一次！</description><copyright>JinzhePro</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://jinzhepro.github.io/logo.png</url><title>avatar</title><link>https://jinzhepro.github.io</link></image><lastBuildDate>Fri, 20 Dec 2024 02:26:28 +0000</lastBuildDate><managingEditor>JinzhePro</managingEditor><ttl>60</ttl><webMaster>JinzhePro</webMaster><item><title>封装axios请求</title><link>https://jinzhepro.github.io/post/feng-zhuang-axios-qing-qiu.html</link><description>封装axios的好处：兼容多种请求方法，不需要关心是怎么调用的，只需要传入相关参数即可使用&#13;
&#13;
我是在webpack项目里，用的到了ES6模块化进行封装&#13;
&#13;
话不多说，上代码：&#13;
&#13;
```jsx&#13;
// 引入axios&#13;
import axios from 'axios';&#13;
&#13;
// axios.create方法会创建一个axios实例，可传入一些默认配置&#13;
const httpServer = axios.create();&#13;
&#13;
// 请求拦截，请求发送之前会触发此方法&#13;
httpServer.interceptors.request.use(&#13;
  (config) =&gt; {&#13;
    // 这里可以做一些操作&#13;
    config.method = config.method || 'get'; // 区分请求方式&#13;
    return config;&#13;
  },&#13;
  (error) =&gt; {&#13;
    return Promise.reject(error); // 捕获错误&#13;
  }&#13;
);&#13;
&#13;
// 返回拦截，返回之前会触发此方法&#13;
httpServer.interceptors.response.use(&#13;
  (response) =&gt; {&#13;
    // 这里可以做一些操作&#13;
    return response;&#13;
  },&#13;
  (error) =&gt; {&#13;
    return Promise.reject(error);&#13;
  }&#13;
);&#13;
&#13;
// 定义请求方法&#13;
const fetchApi = (params) =&gt; {&#13;
  // 返回一个Promise&#13;
  return new Promise((resolve, reject) =&gt; {&#13;
    httpServer(params)&#13;
      .then((response) =&gt; {&#13;
        resolve(response);&#13;
      })&#13;
      .catch((error) =&gt; {&#13;
        // 这里可以加一些UI提示&#13;
        reject(error);&#13;
      });&#13;
  });&#13;
};&#13;
&#13;
export default fetchApi;&#13;
```&#13;
&#13;
如何使用？&#13;
&#13;
```jsx&#13;
// 引入封装好的方法&#13;
import fetchApi from './fetchApi.js';&#13;
&#13;
// 传参&#13;
fetchApi({&#13;
  methods: 'get',&#13;
  data: {&#13;
    id: 1,&#13;
    name: 2,&#13;
  },&#13;
  isLogin: true, //甚至可以有一些自定义的参数，在interceptors.request里通过config.XXX取到&#13;
}).then((res) =&gt; {&#13;
  // 取到返回值&#13;
});&#13;
```。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/feng-zhuang-axios-qing-qiu.html</guid><pubDate>Fri, 20 Dec 2024 02:26:08 +0000</pubDate></item><item><title>编写高质量JavaScript代码</title><link>https://jinzhepro.github.io/post/bian-xie-gao-zhi-liang-JavaScript-dai-ma.html</link><description>本文知识点是摘自于[[汤姆大叔博客](http://www.cnblogs.com/TomXu/)](http://www.cnblogs.com/TomXu/)，自己记录理解并学习&#13;
&#13;
## 书写可维护的代码&#13;
&#13;
软件开发是一个熵增的过程，随着软件结构越来越复杂，代码维护就变得举步维艰，当你发现bug并理解修复他是最好的。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/bian-xie-gao-zhi-liang-JavaScript-dai-ma.html</guid><pubDate>Fri, 20 Dec 2024 02:25:33 +0000</pubDate></item><item><title>V8的垃圾回收器</title><link>https://jinzhepro.github.io/post/V8-de-la-ji-hui-shou-qi.html</link><description>## 垃圾回收算法&#13;
&#13;
1. 遍历GC Root(window，DOM，栈等)标记活动对象和非活动对象&#13;
2. 回收非活动对象所占据的内存&#13;
3. 内存整理&#13;
&#13;
## 新生代和老生代&#13;
&#13;
在V8中，会把堆分成新生代和老生代两个区域&#13;
&#13;
- 新生代通常只支持1~8M的容量，存放生存时间短的对象，由**副垃圾回收器**负责。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/V8-de-la-ji-hui-shou-qi.html</guid><pubDate>Fri, 20 Dec 2024 02:20:22 +0000</pubDate></item><item><title>111</title><link>https://jinzhepro.github.io/post/111.html</link><description># 实体层&#13;
&#13;
使用物理手段链接电脑，如光缆，wifi。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/111.html</guid><pubDate>Thu, 19 Dec 2024 08:42:43 +0000</pubDate></item><item><title>关于我</title><link>https://jinzhepro.github.io/about.html</link><description>## 你好&#13;
### 1213。</description><guid isPermaLink="true">https://jinzhepro.github.io/about.html</guid><pubDate>Thu, 19 Dec 2024 09:40:40 +0000</pubDate></item></channel></rss>