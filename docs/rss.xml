<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>JinzhePro</title><link>https://jinzhepro.github.io</link><description>再努力一次！</description><copyright>JinzhePro</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://jinzhepro.github.io/logo.png</url><title>avatar</title><link>https://jinzhepro.github.io</link></image><lastBuildDate>Fri, 20 Dec 2024 03:12:57 +0000</lastBuildDate><managingEditor>JinzhePro</managingEditor><ttl>60</ttl><webMaster>JinzhePro</webMaster><item><title>缺陷管理分析</title><link>https://jinzhepro.github.io/post/que-xian-guan-li-fen-xi.html</link><description>## 缺陷控制&#13;
&#13;
在项目的全生命周期内，保障项目质量的一系列行为&#13;
&#13;
## 缺陷问题&#13;
&#13;
- 需求不明确 ---- 返工 --- 沟通/督办&#13;
- 进度超期 --- 加班 --- 缺陷跟踪&#13;
- 工程有bug --- 难维护 --- 代码规范&#13;
- 协同 ---效率低 --- 清单/代办&#13;
&#13;
## 缺陷跟踪软件&#13;
&#13;
帮助质量保证，在工作中维护软件的跟踪报告，主要作用是开发状态，集中概览，提供报告&#13;
&#13;
## 总结&#13;
&#13;
- 分工明确，责任到人&#13;
- 借助工具，提升效率&#13;
- 按需取用&#13;
&#13;
## 最佳实践&#13;
&#13;
### 代码（个人）&#13;
&#13;
- 代码自检&#13;
- 版本控制&#13;
- snippets（代码片段）&#13;
&#13;
### 团队&#13;
&#13;
- 互相监督&#13;
- 分工明确&#13;
- 代码Review&#13;
&#13;
### 项目&#13;
&#13;
- 制定计划&#13;
- 项目经理Push&#13;
- 协商沟通&#13;
- 纠正措施&#13;
- 备选方案&#13;
&#13;
### 公司&#13;
&#13;
- 缺陷管理软件&#13;
- 奖惩有度&#13;
- 质量改进&#13;
- 总结推演。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/que-xian-guan-li-fen-xi.html</guid><pubDate>Fri, 20 Dec 2024 03:12:35 +0000</pubDate></item><item><title>预处理</title><link>https://jinzhepro.github.io/post/yu-chu-li.html</link><description>提前处理var、 const、 let、 function声明、 class声明 。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/yu-chu-li.html</guid><pubDate>Fri, 20 Dec 2024 03:11:48 +0000</pubDate></item><item><title>V8</title><link>https://jinzhepro.github.io/post/V8.html</link><description>V8是一个虚拟机，作为js的执行环境，它可以模拟cpu，堆栈，寄存器等&#13;
&#13;
- 指令集（机器语言）： cpu只能识别的二进制指令如（1000100111011000）&#13;
- 汇编指令集： 人类可识别记忆的符号（mov ax,bx）&#13;
&#13;
## 高级语言的处理&#13;
&#13;
- 解释执行（启动快，执行慢）：源代码通过解析器编译成字节码，然后使用解释器解释执行字节码直接输出结果。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/V8.html</guid><pubDate>Fri, 20 Dec 2024 03:11:15 +0000</pubDate></item><item><title>链表</title><link>https://jinzhepro.github.io/post/lian-biao.html</link><description>线性结构，内存不连续&#13;
&#13;
## 单链表&#13;
![232941876-3febd2b0-c227-4bbf-863f-9b60044c2dba](https://github.com/user-attachments/assets/7c5e8d16-4723-4afb-ba50-291f79d08573)&#13;
&#13;
- 头结点&#13;
- 后继指针&#13;
- 尾节点&#13;
- 空地址null&#13;
&#13;
### 插入和删除&#13;
![232941955-353a3f32-f366-4932-a544-a2b1dbb0faa7](https://github.com/user-attachments/assets/03debb37-51e6-47ae-9380-54f81f8d788c)&#13;
&#13;
### 查找&#13;
&#13;
链表不支持随机访问,所以需要遍历节点,时间复杂度O(n)&#13;
&#13;
### 代码&#13;
&#13;
使用数组模拟&#13;
&#13;
```jsx&#13;
class Node {&#13;
  // 单个节点&#13;
  constructor(data, next) {&#13;
    this.data = data;&#13;
    this.next = next;&#13;
  }&#13;
}&#13;
class NodeList {&#13;
  constructor(list) {&#13;
    // 初始化数据&#13;
    this.list = [2, 4, 3, 5, 6, 8, 45, 34, 32];&#13;
    this.nodeList = [];&#13;
    this.createNodeList();&#13;
  }&#13;
&#13;
  // 创建节点&#13;
  createNodeList() {&#13;
    for (let i = 0; i &lt; this.list.length; i++) {&#13;
      const node = new Node(this.list[i], this.list[i + 1] || null);&#13;
      this.nodeList.push(node);&#13;
    }&#13;
    return this.nodeList;&#13;
  }&#13;
&#13;
  insertNode({ preData, data }) {&#13;
    for (let i = 0; i &lt; this.nodeList.length; i++) {&#13;
      // 查找前驱节点&#13;
      if (this.nodeList[i].data === preData) {&#13;
        // 构建节点&#13;
        const node = new Node(&#13;
          data,&#13;
          this.nodeList[i + 1] ? this.nodeList[i + 1].data : null&#13;
        );&#13;
        // 插入&#13;
        this.nodeList.splice(i, 1, node);&#13;
      }&#13;
    }&#13;
    return this.nodeList;&#13;
  }&#13;
&#13;
  // 删除节点&#13;
  removeNode({ data }) {&#13;
    for (let i = 0; i &lt; this.nodeList.length; i++) {&#13;
      // 查找前驱节点&#13;
      if (this.nodeList[i].data === data) {&#13;
        // 修改前驱结点的next指向&#13;
        this.nodeList[i - 1] &amp;&amp;&#13;
          (this.nodeList[i - 1].next = this.nodeList[i + 1].data);&#13;
      }&#13;
    }&#13;
    return this.nodeList;&#13;
  }&#13;
}&#13;
&#13;
const nodeList = new NodeList();&#13;
nodeList.insertNode({ preData: 8, data: 50 });&#13;
nodeList.removeNode({ data: 50 });&#13;
console.log(nodeList);&#13;
```&#13;
&#13;
## 循环链表&#13;
![232942004-5c2690af-31c0-42ff-ae78-f681d2b35ae5](https://github.com/user-attachments/assets/76cb6b29-b76a-4a07-a0dd-0534cb587717)&#13;
&#13;
## 双向链表&#13;
![232942082-6f0c50af-26df-4e54-8758-389a8d60b1de](https://github.com/user-attachments/assets/a20c1a11-6433-45ad-9db4-9bcab4ae275f)&#13;
&#13;
&#13;
### 查找 删除 添加&#13;
&#13;
可以通过前驱结点直接查找,时间复杂度为O(1)&#13;
&#13;
## 双向循环链表&#13;
![232942116-d75284fd-2d18-4936-824f-46a1e171a910](https://github.com/user-attachments/assets/1d5e7db9-41e4-4b6d-81a5-416518b9199c)&#13;
&#13;
## 链表和数组的比较&#13;
&#13;
| | 数组| 链表|&#13;
|--------|--------|--------|&#13;
| 插入,删除| O(n)| O(1)|&#13;
| 随机访问| O(1)| O(n)|&#13;
| 内存| 连续内存,大小固定| 不连续内存,动态扩容|&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/lian-biao.html</guid><pubDate>Fri, 20 Dec 2024 03:09:36 +0000</pubDate></item><item><title>Proxy</title><link>https://jinzhepro.github.io/post/Proxy.html</link><description>Proxy可以创建一个对象的代理，实现对操作的劫持。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/Proxy.html</guid><pubDate>Fri, 20 Dec 2024 03:02:10 +0000</pubDate></item><item><title>V8是如何提升对象访问速度</title><link>https://jinzhepro.github.io/post/V8-shi-ru-he-ti-sheng-dui-xiang-fang-wen-su-du.html</link><description>## 常规属性（properties）和排序属性（element）&#13;
&#13;
对象中的字符串属性被称为properties，是按照创建的顺序；数字属性被称为element，按照索引值大小排序。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/V8-shi-ru-he-ti-sheng-dui-xiang-fang-wen-su-du.html</guid><pubDate>Fri, 20 Dec 2024 03:01:29 +0000</pubDate></item><item><title>执行上下文</title><link>https://jinzhepro.github.io/post/zhi-xing-shang-xia-wen.html</link><description>函数运行时所需要的信息&#13;
&#13;
## 在最新的ES2018中，执行上下文包括&#13;
&#13;
1. 词法环境（获取变量或this时）&#13;
2. 变量对象（声明变量时）&#13;
3. code evaluation state：恢复代码执行位置&#13;
4. Function：正在被执行的函数&#13;
5. Realm：‘国度’，代表了基础库和内置对象的实例&#13;
6. Generator：生成器&#13;
&#13;
### 在生成执行上下文的时候有两个阶段：生成阶段和执行阶段。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/zhi-xing-shang-xia-wen.html</guid><pubDate>Fri, 20 Dec 2024 02:59:51 +0000</pubDate></item><item><title>版本号</title><link>https://jinzhepro.github.io/post/ban-ben-hao.html</link><description>alpha：内部测试版本，测试或开发人员使用&#13;
&#13;
beta：公测版本，消除了严重bug，还有新功能添加&#13;
&#13;
rc: 发行候选版本，主要是修改bug，不做功能改变&#13;
&#13;
release：发行版&#13;
&#13;
## 例如&#13;
&#13;
1&lt;sup&gt;（主版本）&lt;/sup&gt;.2&lt;sup&gt;（次版本）&lt;/sup&gt;.3&lt;sup&gt;（修订号）&lt;/sup&gt;- alpha.1&lt;sup&gt;（内部测试版本号）&lt;/sup&gt;-beta.1&lt;sup&gt;（公测版本号）&lt;/sup&gt;-rc.1&lt;sup&gt;（发行候选版本）&lt;/sup&gt;-release.1&lt;sup&gt;（发行版）&lt;/sup&gt;+meta&lt;sup&gt;（元数据）&lt;/sup&gt;。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/ban-ben-hao.html</guid><pubDate>Fri, 20 Dec 2024 02:59:13 +0000</pubDate></item><item><title>数组</title><link>https://jinzhepro.github.io/post/shu-zu.html</link><description>- 线性表结构&#13;
- 使用一组连续的内存空间&#13;
- 相同类型数据&#13;
&#13;
## 线性表结构&#13;
&#13;
数据像一条线一样的结构,只有前,后两个方向.如链表,队列,栈等&#13;
&#13;
连续内存空间&#13;
&#13;
- 随机访问&#13;
- 插入,删除就要做大量的迁移工作&#13;
&#13;
![233517526-8c2eebaf-a4ec-4821-b410-0348c697da76](https://github.com/user-attachments/assets/32a07dd3-76d2-4f9c-85af-b6b55dbb28fa)&#13;
&#13;
&#13;
内存地址: `a[i]_address = base_address + i * data_type_size`&#13;
&#13;
## 低效的“插入”和“删除”&#13;
&#13;
如果我们在数组最后插入或删除,复杂度为O(1),如果在中间为O(n)&#13;
&#13;
### 优化&#13;
&#13;
插入:如果数组只是数据集,数据没有规律的情况下,我们可以把插入变成移动.&#13;
![233517689-105e8010-8c2e-4d10-9c7b-6d53b027a65d](https://github.com/user-attachments/assets/262b3109-33cb-41e1-ad7d-db7d616e3391)&#13;
&#13;
&#13;
删除:记录删除数据,将多次删除合并为一次删除.&#13;
![233517704-a8e0e995-be70-4d08-a3d3-4b669646197d](https://github.com/user-attachments/assets/e0243ecc-7bf0-4224-a6a2-ba3d94944948)&#13;
&#13;
&#13;
## 越界问题&#13;
&#13;
访问到不属于该数组的一块内存地址上,造成bug.。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/shu-zu.html</guid><pubDate>Fri, 20 Dec 2024 02:56:35 +0000</pubDate></item><item><title>二叉树</title><link>https://jinzhepro.github.io/post/er-cha-shu.html</link><description>## 父节点、子节点、根节点、兄弟节点、叶子节点&#13;
&#13;
- A 节点就是 B 节点的**父节点**，B 节点是 A 节点的**子节点**。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/er-cha-shu.html</guid><pubDate>Fri, 20 Dec 2024 02:52:54 +0000</pubDate></item><item><title>V8的浏览器运行时环境</title><link>https://jinzhepro.github.io/post/V8-de-liu-lan-qi-yun-xing-shi-huan-jing.html</link><description>## 堆栈&#13;
&#13;
在chrome中，只要打开一个渲染进程，浏览器就会初始化V8，同时初始化堆和栈。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/V8-de-liu-lan-qi-yun-xing-shi-huan-jing.html</guid><pubDate>Fri, 20 Dec 2024 02:47:31 +0000</pubDate></item><item><title>二叉查找树</title><link>https://jinzhepro.github.io/post/er-cha-cha-zhao-shu.html</link><description>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/er-cha-cha-zhao-shu.html</guid><pubDate>Fri, 20 Dec 2024 02:46:25 +0000</pubDate></item><item><title>宏任务和微任务</title><link>https://jinzhepro.github.io/post/hong-ren-wu-he-wei-ren-wu.html</link><description>- 宏任务是指消息队列中等待被主线程执行的事件。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/hong-ren-wu-he-wei-ren-wu.html</guid><pubDate>Fri, 20 Dec 2024 02:39:05 +0000</pubDate></item><item><title>语句的执行</title><link>https://jinzhepro.github.io/post/yu-ju-de-zhi-xing.html</link><description>## Completion Record 标准类型&#13;
&#13;
1. [[type]]：完成的类型（break、continue、return、throw、normal）&#13;
2. [[value]] ：返回值（如果没有，则为empty）&#13;
3. [[target]] ：语句的目标&#13;
&#13;
```jsx&#13;
{&#13;
  var a = 1; // normal, undefined, empty&#13;
  return 2; // return, 2, empty&#13;
  a++;&#13;
  console.log(a);&#13;
} // return, 2, empty&#13;
// 带有target的语句&#13;
outer: while (true) {&#13;
  inner: while (true) {&#13;
    break outer;&#13;
  }&#13;
}&#13;
console.log('finished');&#13;
```。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/yu-ju-de-zhi-xing.html</guid><pubDate>Fri, 20 Dec 2024 02:38:00 +0000</pubDate></item><item><title>异步编程</title><link>https://jinzhepro.github.io/post/yi-bu-bian-cheng.html</link><description>## 回调函数&#13;
&#13;
最原始的异步编程方法（回调地狱）&#13;
&#13;
## Promise&#13;
&#13;
在一定程度上解决了回调地狱的问题，但是then多了之后也不太友好。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/yi-bu-bian-cheng.html</guid><pubDate>Fri, 20 Dec 2024 02:37:25 +0000</pubDate></item><item><title>复杂度分析</title><link>https://jinzhepro.github.io/post/fu-za-du-fen-xi.html</link><description>&gt; 复杂度分析是学习数据结构与算法的前提。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/fu-za-du-fen-xi.html</guid><pubDate>Fri, 20 Dec 2024 02:31:16 +0000</pubDate></item><item><title>JavaScript手写函数</title><link>https://jinzhepro.github.io/post/JavaScript-shou-xie-han-shu.html</link><description>## 手写一个new&#13;
&#13;
```jsx&#13;
function create() {&#13;
  // 创建一个空对象&#13;
  let obj = new Object();&#13;
&#13;
  // 参数转数组&#13;
  var args = Array.prototype.slice.call(arguments);&#13;
&#13;
  // 获取构造函数&#13;
  let Con = args[0];&#13;
&#13;
  // 链接原型&#13;
  obj._proto_ = Con.prototype;&#13;
&#13;
  // binding this&#13;
  let result = Con.apply(obj, args.slice(1));&#13;
&#13;
  // return obj&#13;
  return typeof result === 'object' ? result : obj;&#13;
}&#13;
```&#13;
&#13;
## 手写一个call&#13;
&#13;
```jsx&#13;
Function.prototype.myCall = function (params) {&#13;
  // 获取对象&#13;
  let params = params || window;&#13;
&#13;
  // 将作用域添加到新函数里&#13;
  params.fn = this;&#13;
&#13;
  // 获取参数&#13;
  let args = [...arguments].slice(1);&#13;
&#13;
  // 执行新函数&#13;
  let result = parmas.fn(...args);&#13;
&#13;
  // 删除函数&#13;
  delete params.fn;&#13;
&#13;
  return result;&#13;
};&#13;
```&#13;
&#13;
## 手写一个apply&#13;
&#13;
```jsx&#13;
Function.prototype.myApply = function (params) {&#13;
  // 获取对象&#13;
  let params = params || window;&#13;
&#13;
  // 将作用域添加到新函数里&#13;
  params.fn = this;&#13;
&#13;
  let result = null;&#13;
  if (argments[1]) {&#13;
    result = parmas.fn(...arguments[1]);&#13;
  } else {&#13;
    result = parmas.fn();&#13;
  }&#13;
&#13;
  // 删除函数&#13;
  delete params.fn;&#13;
&#13;
  return result;&#13;
};&#13;
```&#13;
&#13;
## 手写一个bind&#13;
&#13;
```jsx&#13;
Function.prototype.myBind = function (context) {&#13;
  let _this = this;&#13;
  return function F() {&#13;
    if (this instanceof F) {&#13;
      return new _this(...arguments);&#13;
    }&#13;
    return _this.apply(context, [...arguments]);&#13;
  };&#13;
};&#13;
```&#13;
&#13;
## 手写一个防抖函数&#13;
&#13;
防抖函数的作用是事件调用之后隔一段时间再处理函数，如果在时间之内再次触发事件就清除原来的时间重新计时。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/JavaScript-shou-xie-han-shu.html</guid><pubDate>Fri, 20 Dec 2024 02:30:15 +0000</pubDate></item><item><title>JavaScript中的this</title><link>https://jinzhepro.github.io/post/JavaScript-zhong-de-this.html</link><description>this和切换执行上下文有关，取决于函数执行时刻，调用函数时所使用的引用。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/JavaScript-zhong-de-this.html</guid><pubDate>Fri, 20 Dec 2024 02:29:23 +0000</pubDate></item><item><title>TypeScript基础语法</title><link>https://jinzhepro.github.io/post/TypeScript-ji-chu-yu-fa.html</link><description>## 类型声明&#13;
&#13;
使用 :[type] 指定变量的类型&#13;
&#13;
```tsx&#13;
let a: number = 1 // 数字&#13;
let b: string = 'zhang' // 字符串&#13;
let c: boolean = true // 布尔&#13;
let d: object = {} // 对象&#13;
let e: array = [] // 数组&#13;
let f: null = null // Null&#13;
let g: undefined = undefined // Undefined&#13;
let h: void = function(){} // 空值&#13;
let i: any = [] // 表示任意类型，可以链式传播，不会对其进行类型检查&#13;
let j: unknown; // 表示不确定类型，只能赋值给unknown和any，会进行类型检测&#13;
let k: never; // 表示一个不可能出现的值，比如抛出错误，无限循环，并可以模拟只读属性&#13;
// 未声明类型的变量默认为any&#13;
let something === let something: any;&#13;
```&#13;
&#13;
## 类型推论&#13;
&#13;
如果没有指定类型，那么TS会按照类型推论推断出一个类型&#13;
&#13;
```tsx&#13;
let myFavoriteNumber = 'seven';&#13;
myFavoriteNumber = 7; // error&#13;
```&#13;
&#13;
## 联合类型&#13;
&#13;
表示可以取多个类型的一种&#13;
&#13;
```tsx&#13;
let myFavoriteNumber: string | number;&#13;
myFavoriteNumber = 'seven';&#13;
myFavoriteNumber = 7;&#13;
// 只能访问联合类型的共有属性（类型推断）&#13;
function getLength(something: string | number): number {&#13;
  return something.toString();&#13;
}&#13;
```&#13;
&#13;
## 对象类型（interface）&#13;
&#13;
我们使用接口（Interfaces）来定义对象的类型。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/TypeScript-ji-chu-yu-fa.html</guid><pubDate>Fri, 20 Dec 2024 02:28:13 +0000</pubDate></item><item><title>前端自动化</title><link>https://jinzhepro.github.io/post/qian-duan-zi-dong-hua.html</link><description>## 前端自动化&#13;
&#13;
前端代码的自动化构建,打包,测试,部署等一系列流程&#13;
&#13;
### CI&#13;
&#13;
持续集成：不断开发新的功能,并通过测试快速发现新功能是否可与旧版本集成.&#13;
&#13;
### CD&#13;
&#13;
持续部署：不断的经过测试用例的校验,并将代码发布到测试或生产环境&#13;
&#13;
### 意义&#13;
&#13;
- 相比人工稳定,提升软件质量&#13;
- 效率迭代,便捷部署&#13;
- 快速交付,便于管理。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/qian-duan-zi-dong-hua.html</guid><pubDate>Fri, 20 Dec 2024 02:27:15 +0000</pubDate></item><item><title>封装axios请求</title><link>https://jinzhepro.github.io/post/feng-zhuang-axios-qing-qiu.html</link><description>封装axios的好处：兼容多种请求方法，不需要关心是怎么调用的，只需要传入相关参数即可使用&#13;
&#13;
我是在webpack项目里，用的到了ES6模块化进行封装&#13;
&#13;
话不多说，上代码：&#13;
&#13;
```jsx&#13;
// 引入axios&#13;
import axios from 'axios';&#13;
&#13;
// axios.create方法会创建一个axios实例，可传入一些默认配置&#13;
const httpServer = axios.create();&#13;
&#13;
// 请求拦截，请求发送之前会触发此方法&#13;
httpServer.interceptors.request.use(&#13;
  (config) =&gt; {&#13;
    // 这里可以做一些操作&#13;
    config.method = config.method || 'get'; // 区分请求方式&#13;
    return config;&#13;
  },&#13;
  (error) =&gt; {&#13;
    return Promise.reject(error); // 捕获错误&#13;
  }&#13;
);&#13;
&#13;
// 返回拦截，返回之前会触发此方法&#13;
httpServer.interceptors.response.use(&#13;
  (response) =&gt; {&#13;
    // 这里可以做一些操作&#13;
    return response;&#13;
  },&#13;
  (error) =&gt; {&#13;
    return Promise.reject(error);&#13;
  }&#13;
);&#13;
&#13;
// 定义请求方法&#13;
const fetchApi = (params) =&gt; {&#13;
  // 返回一个Promise&#13;
  return new Promise((resolve, reject) =&gt; {&#13;
    httpServer(params)&#13;
      .then((response) =&gt; {&#13;
        resolve(response);&#13;
      })&#13;
      .catch((error) =&gt; {&#13;
        // 这里可以加一些UI提示&#13;
        reject(error);&#13;
      });&#13;
  });&#13;
};&#13;
&#13;
export default fetchApi;&#13;
```&#13;
&#13;
如何使用？&#13;
&#13;
```jsx&#13;
// 引入封装好的方法&#13;
import fetchApi from './fetchApi.js';&#13;
&#13;
// 传参&#13;
fetchApi({&#13;
  methods: 'get',&#13;
  data: {&#13;
    id: 1,&#13;
    name: 2,&#13;
  },&#13;
  isLogin: true, //甚至可以有一些自定义的参数，在interceptors.request里通过config.XXX取到&#13;
}).then((res) =&gt; {&#13;
  // 取到返回值&#13;
});&#13;
```。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/feng-zhuang-axios-qing-qiu.html</guid><pubDate>Fri, 20 Dec 2024 02:26:08 +0000</pubDate></item><item><title>编写高质量JavaScript代码</title><link>https://jinzhepro.github.io/post/bian-xie-gao-zhi-liang-JavaScript-dai-ma.html</link><description>本文知识点是摘自于[[汤姆大叔博客](http://www.cnblogs.com/TomXu/)](http://www.cnblogs.com/TomXu/)，自己记录理解并学习&#13;
&#13;
## 书写可维护的代码&#13;
&#13;
软件开发是一个熵增的过程，随着软件结构越来越复杂，代码维护就变得举步维艰，当你发现bug并理解修复他是最好的。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/bian-xie-gao-zhi-liang-JavaScript-dai-ma.html</guid><pubDate>Fri, 20 Dec 2024 02:25:33 +0000</pubDate></item><item><title>V8的垃圾回收器</title><link>https://jinzhepro.github.io/post/V8-de-la-ji-hui-shou-qi.html</link><description>## 垃圾回收算法&#13;
&#13;
1. 遍历GC Root(window，DOM，栈等)标记活动对象和非活动对象&#13;
2. 回收非活动对象所占据的内存&#13;
3. 内存整理&#13;
&#13;
## 新生代和老生代&#13;
&#13;
在V8中，会把堆分成新生代和老生代两个区域&#13;
&#13;
- 新生代通常只支持1~8M的容量，存放生存时间短的对象，由**副垃圾回收器**负责。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/V8-de-la-ji-hui-shou-qi.html</guid><pubDate>Fri, 20 Dec 2024 02:20:22 +0000</pubDate></item><item><title>111</title><link>https://jinzhepro.github.io/post/111.html</link><description># 实体层&#13;
&#13;
使用物理手段链接电脑，如光缆，wifi。</description><guid isPermaLink="true">https://jinzhepro.github.io/post/111.html</guid><pubDate>Thu, 19 Dec 2024 08:42:43 +0000</pubDate></item><item><title>关于我</title><link>https://jinzhepro.github.io/about.html</link><description>## 你好&#13;
### 1213。</description><guid isPermaLink="true">https://jinzhepro.github.io/about.html</guid><pubDate>Thu, 19 Dec 2024 09:40:40 +0000</pubDate></item></channel></rss>