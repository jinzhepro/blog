## 垃圾回收算法

1. 遍历GC Root(window，DOM，栈等)标记活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 内存整理

## 新生代和老生代

在V8中，会把堆分成新生代和老生代两个区域

- 新生代通常只支持1~8M的容量，存放生存时间短的对象，由**副垃圾回收器**负责。
- 老生代通常容量很大，存放生存时间长的对象，由**主垃圾回收器**负责。

### Scavenge 算法（新生代）

在新生代中被划分为对象区和空闲区，新加入的对象全部加入对象区，当对象区快被写满时，就要进行一次垃圾回收操作。

![233526686-e6ff7885-80c1-4fa5-86bf-b3367affc303](https://github.com/user-attachments/assets/c7251646-92ab-4807-a785-386a403228bb)

### 回收过程


**因为要做频繁的复制操作，所以新生代一般设置容量较小。**

副垃圾回收器还会采用**对象晋升策略**，移动两次仍然还存在就把它移动到老生代中去。

![233526851-25448ec7-81e2-46c6-af5e-d59afaeed3aa](https://github.com/user-attachments/assets/38f2b10b-3fac-4d62-8259-6fe19d63de5b)

1. 垃圾标记
2. 副垃圾回收器把活动对象复制到空闲区，整理
3. 两个区做一次交换，对象区变成空闲区，空闲区变成对象区
4. 抹掉空闲区

### 标记算法（老生代）

- 标记-清除从根开始遍历，标记那些不能被到达的元素，直接清除掉。会出现内存碎片所以接下来要整理操作。
- 标记-整理标记活动对象，将它们移动到一端，然后清理掉后面的内存。

## 垃圾回收器的优化

垃圾回收是运行在主线程上的，所以进行垃圾回收时，会造成卡顿。

- 并行回收，开多个线程同时进行
- 增量回收，将垃圾收集分解成更小的颗粒，穿插的进行，一次只进行一小部分操作。
- 并发回收，在主线程内，辅助线程可以在后台完成垃圾回收操作。
- 